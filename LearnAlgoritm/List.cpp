#include "List.h"
#include <iostream>

void List::push_back(int data)
{
	Node* node = new Node(data);
	if (m_head == nullptr)
	{
		m_head = node;
		return;
	}
	Node* last = m_head;
	while (last->m_next !=  nullptr)
	{
		last = last->m_next;
	}
	last->m_next = node;
	return;
}

void List::push_front(int data)
{
	Node* node = new Node(data);
	node->m_next = m_head;
	m_head = node;
}

void List::insert(int pos,int data)
{
	Node* node = new Node(data);

	if (m_head == nullptr)
	{
		// если список пуст, новый узел и будет началом списка
		m_head = node;
		return;
	}

	if (pos == 0)
	{
		// крайний случай - вставка  в начало списка
		node->m_next = m_head;
		m_head = node;
		return;
	}
	int currPos = 0;

	Node* current = m_head;
	// в цикле идем по списку, пока список не кончится, или пока не дойдем до позиции
	while (currPos < pos - 1 && current->m_next != nullptr)
	{
		current = current->m_next;
		currPos++;
	}
	// меняем указатель на следующий узел на указатель на новый узел
	Node* next = current->m_next;
	current->m_next = node;
	// связываем список обратно, меняем указатель на узел, следующий после нового узла, на указатель на узел, следующий за current
	node->m_next = next;

}

void List::deleteNode(int data)
{
	Node* temp = m_head;
	Node* prev = nullptr;

	// крайний случай удаления начала списка
	if (temp && temp->m_data == data)
	{
		m_head = temp->m_next;
		delete temp;
		return;
	}
	// идем по списку, пока не найдем узел со значением данных, равных ключу
	while (temp && temp->m_data != data)
	{
		prev = temp;
		temp = temp->m_next;
	}
	// если узел не найден, возвращаем
	if (!temp)
		return;
	// меняем указатель следующего узла для предыдущего узла на узел, следующий за удаляемым узлом, и удаляем узел с данными
	prev->m_next = temp->m_next;
	delete temp;
}
void List::deleteNodeByPos(int pos)
{
	if (m_head == nullptr) {
		std::cout << "Список пуст, удаление невозможно." << std::endl;
		return;
	}

	if (pos == 0) {
		Node* temp = m_head;
		m_head = m_head->m_next;
		delete temp;
		return;
	}

	int currPos = 0;
	Node* current = m_head;
	Node* prev = nullptr;

	while (current != nullptr && currPos != pos) {
		prev = current;
		current = current->m_next;
		currPos++;
	}

	if (current == nullptr) {
		std::cout << "Указана недопустимая позиция для удаления." << std::endl;
		return;
	}

	prev->m_next = current->m_next;
	delete current;
}

void List::show()
{
	Node* current = m_head;
	std::cout << "Содержимое списка: ";
	while (current != nullptr)
	{
		std::cout << current->m_data << " ";
		current = current->m_next;
	}
	std::cout << std::endl;
}